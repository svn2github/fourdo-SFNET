<TITLE>C Programming for deeply embedded applications</TITLE><H1><LINK NAME="XREF10783">C Programming for deeply embedded </LINK>applications</H1><HR><H2>About this recipe</H2>In this recipe you will learn about the standalone runtime support system for C programming in deeply embedded applications.  In particular you will discover:<P><UL><LI>what <B>rtstand.s</B> supports;<LI>how to make use of it by looking at example programs;<LI>how to extend it by adding extra fuctionality from the C library;<LI>the size of the standalone run time library;</UL><H2>Introduction</H2>The semi hosted ANSI C library provides all the standard C library facilities (and thus is quite large).  This is acceptable when running  under emulation with plenty of memory available, or maybe even when running on development hardware with access to a real debugging channel and plenty of memory. However, in a deeply embedded application many of the facilities of the C library may no longer be relevent, eg. file access functions, time and date functions, and the size of the semi hosted ANSI C library may be prohibitive if the memory available is severely limited.<P>For deeply embedded applications a minimal C runtime system is needed which takes up as little memory as possible, is easily portable to the target hardware, and only supports those functions required for such an application.<P>The ARM Software Development Toolkit comes with a minimal runtime system in source form.  The 'behind the scenes' jobs which it performs are:<P><UL><LI>setting up the initial stack and heap, and calling main;<LI>program termination - either automatic (returning from main() or forced - explicitly calling __rt_exit);<LI>simple heap allocation (__rt_alloc);<LI>stack limit checking;<LI>setjmp and longjmp support;<LI>divide and remainder functions (calls to which can be generated by <B>armcc</B>);<LI>high level error handler support (__err_handler);<LI>optional floating point support, and a means to detect whether floating point support is available or not (__rt_fpavailable); </UL>The source code <B>rtstand.s</B> documents the options which you may want to change for your target.  These are not covered in this recipe.  The header file <B>rtstand.h</B> documents the functions which <B>rtstand.s</B> provides to the C programmer.<P>Note that no support is provided for outputting data down the debugging channel.  This can be done, but is specific to the target application.  The example C programs described below use the ARM Debug Monitor available under <B>armsd</B> to output messages using in-line SWIs. <P><H2>Using the standalone runtime system</H2>In this section the main features of the standalone runtime system are demonstrated by example programs.<P>Before attempting any of the demonstrations below create a working directory, and set this up as your current directory.  Copy the contents of the <B>clstand</B> directory into your working directory, and also copy the files <B>fpe*.o</B> from the <B>fpe340</B> directory of the <B>cl</B> directory into your working directory.  You are now ready to experiment with the C standalone runtime system.<P>In the examples below, the following options are passed to <B>armcc</B>, <B>armasm</B>, and in the first case <B>armsd</B>:<P><PRE>--------------------------------------------------------Option          |Description                            ---------------------------------------------------------li             |Specifies that the the target is a                     |little endian ARM.                     ---------------------------------------------------------apcs 3/32bit   |This specifies that the 32 bit variant                 |of APCS 3 should be used.  For armasm                  |this is used to set the built in                       |variable {CONFIG} to 32.               --------------------------------------------------------</PRE><P>These arguments can be changed if the target hardware differs from this configuration.  If the ARM Software Tools have been configured as desired then these options may be omitted, as the tools will default to the configuration time values.<P>These demonstrations are likely to be most useful if the sources <B>rtstand.s</B>, <B>errtest.c</B> and <B>memtest.c</B> are studied in conjunction with this recipe.<P><H2>A simple program</H2>Let us compile the example program <B>errtest.c</B>, and assemble the standalone runtime system.  These can then be linked together to provide an executable image, <B>errtest</B>:<P><CODE><PRE>armcc -c errtest.c -li -apcs 3/32bitarmasm rtstand.s -o rtstand.o -li -apcs 3/32bitarmlink -o errtest errtest.o rtstand.o</CODE></PRE>We can then execute this image under the <B>armsd</B> as follows:<P><CODE><PRE>&gt; armsd -li errtestA.R.M. Source-level Debugger, version 4.10 (A.R.M.) [Aug 26 1992]ARMulator V1.20, 512 Kb RAM, MMU present, Demon 1.01, FPE, Little endian.Object program file errtestarmsd: go(the floating point instruction-set is not available)Using integer arithmetic ...10000 / 0X0000000A = 0X000003E810000 / 0X00000009 = 0X0000045710000 / 0X00000008 = 0X000004E210000 / 0X00000007 = 0X0000059410000 / 0X00000006 = 0X0000068210000 / 0X00000005 = 0X000007D010000 / 0X00000004 = 0X000009C410000 / 0X00000003 = 0X00000D0510000 / 0X00000002 = 0X0000138810000 / 0X00000001 = 0X00002710Program terminated normally at PC = 0x00008550      0x00008550: 0xef000011 .... : &gt;  swi     0x11armsd: quitQuitting&gt; </CODE></PRE>The '&gt;' prompt is the Operating System prompt, and the 'armsd:' prompt is output by <B>armsd</B> to indicate that user input is required.<P>Already several of the standalone runtime system's facilities have been demonstrated:<P><UL><LI>the C stack and heap have been set up;<LI><B>main</B> has clearly been called;<LI>the fact that floating point support is not available has been detected;<LI>the integer division functions  have been used by the compiler.<LI>program termination was successful.</UL><H2>Error handling</H2>The same program, <B>errtest</B>, can also be used to demonstrate error handling, by recompiling <B>errtest.c</B> and predefining the DIVIDE_ERROR macro:<P><CODE><PRE>armcc -c errtest.c -li -apcs 3/32bit -DDIVIDE_ERRORarmlink -o errtest errtest.o rtstand.o</CODE></PRE>Again, we can now execute this image under the <B>armsd</B> as follows:<P><CODE><PRE>&gt; armsd -li errtestA.R.M. Source-level Debugger, version 4.10 (A.R.M.) [Aug 26 1992]ARMulator V1.20, 512 Kb RAM, MMU present, Demon 1.01, FPE, Little endian.Object program file errtestarmsd: go(the floating point instruction-set is not available)Using integer arithmetic ...10000 / 0X0000000A = 0X000003E810000 / 0X00000009 = 0X0000045710000 / 0X00000008 = 0X000004E210000 / 0X00000007 = 0X0000059410000 / 0X00000006 = 0X0000068210000 / 0X00000005 = 0X000007D010000 / 0X00000004 = 0X000009C410000 / 0X00000003 = 0X00000D0510000 / 0X00000002 = 0X0000138810000 / 0X00000001 = 0X0000271010000 / 0X00000000 = errhandler called: code = 0X00000001: divide by 0caller's pc = 0X00008304returning...run time error: divide by 0program terminatedProgram terminated normally at PC = 0x0000854c      0x0000854c: 0xef000011 .... : &gt;  swi     0x11armsd: quitQuitting&gt; </CODE></PRE>This time an integer division by zero has been detected by the standalone runtime system, which called <B>__err_handler</B>.  <B>__err_hander</B> output the first set of error messages in the above output.  Control was then returned to the runtime system which output the second set of error messages and terminated execution.<P><A NAME="XREF40279"><H2>longjmp and setjmp</A></H2>A further demonstration can be made using <B>errtest</B> by predefining the macro LONGJMP to perform a <B>longjmp</B> out of <B>__err_handler</B> back into the user program, thus catching and dealing with the error.  First recompile and link <B>errtest</B>:<P><CODE><PRE>armcc -c errtest.c -li -apcs 3/32bit -DDIVIDE_ERROR -DLONGJMParmlink -o errtest errtest.o rtstand.o</CODE></PRE>Then rerun <B>errtest</B> under <B>armsd</B>.  We expect the integer divide by zero to occur once again:<P><CODE><PRE>&gt; armsd -li errtestA.R.M. Source-level Debugger, version 4.10 (A.R.M.) [Aug 26 1992]ARMulator V1.20, 512 Kb RAM, MMU present, Demon 1.01, FPE, Little endian.Object program file errtestarmsd: go(the floating point instruction-set is not available)Using integer arithmetic ...10000 / 0X0000000A = 0X000003E810000 / 0X00000009 = 0X0000045710000 / 0X00000008 = 0X000004E210000 / 0X00000007 = 0X0000059410000 / 0X00000006 = 0X0000068210000 / 0X00000005 = 0X000007D010000 / 0X00000004 = 0X000009C410000 / 0X00000003 = 0X00000D0510000 / 0X00000002 = 0X0000138810000 / 0X00000001 = 0X0000271010000 / 0X00000000 = errhandler called: code = 0X00000001: divide by 0caller's pc = 0X00008310returning...Returning from __err_handler() with errnum = 0X00000001Program terminated normally at PC = 0x00008558      0x00008558: 0xef000011 .... : &gt;  swi     0x11armsd: quitQuitting&gt; </CODE></PRE>The runtime system detected the integer divide by zero, and as before __err_handler was called, which produced the error messages.  However, this time __err_handler used longjmp to return control to the program, rather than the runtime system.<P><H2>Floating point support</H2>Using <B>errtest</B> we can also demonstrate floating point support.  You should already have copied the appropriate floating point emulator object code into your working directory.  For the configuration used in this example <B>fpe_32l.o</B> is the correct object file.<P>However, in addition to this it is also necessary to link with an fpe <B>stub</B>, which we must compile from the source given (<B>fpestub.s</B>).<P><CODE><PRE>armasm fpestub.s -o fpestub.o -li -apcs 3/32bitarmlink -o errtest errtest.o rtstand.o fpestub.o fpe_32l.o -d</CODE></PRE>The resulting executable, <B>errtest</B>, can be run under <B>armsd</B> as before:<P><CODE><PRE>&gt; armsd -li errtestA.R.M. Source-level Debugger, version 4.10 (A.R.M.) [Aug 26 1992]ARMulator V1.20, 512 Kb RAM, MMU present, Demon 1.01, FPE, Little endian.Object program file errtestarmsd: go(the floating point instruction-set is available)Using Floating point, but casting to int ...10000 / 0X0000000A = 0X000003E810000 / 0X00000009 = 0X0000045710000 / 0X00000008 = 0X000004E210000 / 0X00000007 = 0X0000059410000 / 0X00000006 = 0X0000068210000 / 0X00000005 = 0X000007D010000 / 0X00000004 = 0X000009C410000 / 0X00000003 = 0X00000D0510000 / 0X00000002 = 0X0000138810000 / 0X00000001 = 0X0000271010000 / 0X00000000 = errhandler called: code = 0X80000202: Floating PointException : Divide By Zerocaller's pc = 0XE92DE000returning...Returning from __err_handler() with errnum = 0X80000202Program terminated normally at PC = 0x00008558 (__rt_exit + 0x10)+0010 0x00008558: 0xef000011 .... : &gt;  swi     0x11armsd: quitQuitting&gt; </CODE></PRE>This time the floating point instruction set is found to be available, and when a floating point division by zero is attempted, <B>__err_handler</B> is called with the details of the floating point divide by zero exception.<P>Note that if you have compiled <B>errtest.c</B> other than as in <A HREF="#XREF40279">longjmp and setjmp</A>, you will not see precisely this dialogue with <B>armsd</B>.<P><H2>Running out of heap</H2>A second example program, <B>memtest.c</B> demonstrates how the standalone runtime system copes with allocating stack space, and also demonstrates the simple memory allocation function <B>__rt_alloc</B>.  Let us first compile this program so that it should repeatedly request more memory, until there is none left:<P><CODE><PRE>armcc -li -apcs 3/32bit memtest.c -carmlink -o memtest memtest.o rtstand.o</CODE></PRE>This can be run under <B>armsd</B> in the usual way:<P><CODE><PRE>&gt; armsd -li memtestA.R.M. Source-level Debugger, version 4.10 (A.R.M.) [Aug 26 1992]ARMulator V1.20, 512 Kb RAM, MMU present, Demon 1.01, FPE, Little endian.Object program file memtestarmsd: gokernel memory management testforce stack to 4KBrequest 0 words of heap - allocate 256 words at 0X000085A0force stack to 8KB..force stack to 60KBrequest 33211 words of heap - allocate 33211 words at 0X00049388force stack to 64KBrequest 49816 words of heap - allocate 5739 words at 0X00069A74memory exhausted, 105376 words of heap, 64KB of stackProgram terminated normally at PC = 0x0000847c      0x0000847c: 0xef000011 .... : &gt;  swi     0x11armsd: quitQuitting&gt; </CODE></PRE>This demonstrates that allocating space on the stack is working correctly, and also that the <B>__rt_alloc</B> routine is working as expected.  The program terminated because in the end <B>__rt_alloc</B> could not allocate the requested amount of memory.<P><A NAME="XREF38409"><H2>Stack overflow checking</A></H2><B>memtest</B> can also be used to demonstrate stack overflow checking by recompiling with the macro STACK_OVERFLOW defined.  In this case the amount of stack required is increased until there is not enough stack available, and stack overflow detection causes the program to be aborted.<P>To recompile and link <B>memtest.c</B> issue the following commands:<P><CODE><PRE>armcc -li -apcs 3/32bit memtest.c -c -DSTACK_OVERFLOWarmlink -o memtest memtest.o rtstand.o</CODE></PRE>Running this program under <B>armsd</B> produces the following output:<P><CODE><PRE>&gt; armsd -li memtestA.R.M. Source-level Debugger, version 4.10 (A.R.M.) [Aug 26 1992]ARMulator V1.20, 512 Kb RAM, MMU present, Demon 1.01, FPE, Little endian.Object program file memtestarmsd: gokernel memory management testforce stack to 4KB...force stack to 256KBrequest 1296 words of heap - allocate 1296 words at 0X0000AE20force stack to 512KBrun time error: stack overflowprogram terminatedProgram terminated normally at PC = 0x0000847c      0x0000847c: 0xef000011 .... : &gt;  swi     0x11armsd: quitQuitting&gt; </CODE></PRE>Clearly stack overlfow checking did indeed catch the case where too much stack was required, and caused the runtime system to terminate the program after giving an appropriate diagnostic.<P><H2>Extending the standalone runtime system</H2>For a many applications it may be desirable to have access to more of the standard C library than just the minimal runtime system provides.  This section demonstrates how to take out a part of the standard C library and plug it into the standalone runtime system.<P>The function which we will add to <B>rtstand</B> is <B>memmove</B>.  Although this is small, and easily extracted from the C library source, the same methodology can be applied to larger sections of the C library, eg. the dynamic memory allocation system (malloc, free, etc).<P>The source of the C library can be found in the <B>cl</B> directory.  The source for the <B>memmove</B> function is in <B>string.c</B>.  The extracted source for <B>memmove</B> has been put into <B>memmove.c</B>, and the compile time option <B>_copywords</B> has been removed.  The function declaration for <B>memmove</B> and a typedef for <B>size_t</B> (extracted from <B>include/stddef.h</B>) have been put into <B>memmove.h</B>.<P>Our memmove module can be compiled as follows.<P><CODE><PRE>armcc -c memmove.c -li -apcs 3/32bit</CODE></PRE>The output, <B>memmove.o</B> can be linkedwith the user's other object modules together with rtstand.o in the normal way (see previous examples in this section).<P><H2>The size of the standalone runtime library</H2><B>rtstand.s</B> has been separated into several code Areas.  The advantage of this is that <B>armlink</B> can detect if any Areas are unreferenced, and then eliminate them from the output image.<P>The table below shows the typical size of the Areas in <B>rtstand.o</B>:<P><PRE>---------------------------------------------------------Area                 |Size   |Functions                                       |(bytes)|                           ---------------------------------------------------------C$$data              |4      |                           ---------------------------------------------------------C$$code$$__main      |96     |__main, __rt_exit          ---------------------------------------------------------C$$code$$__rt_fpavail|8      |__rt_fpavailable           able                 |       |                           ---------------------------------------------------------C$$code$$__rt_trap   |128    |__rt_trap                  ---------------------------------------------------------C$$code$$__rt_alloc  |68     |__rt_alloc                 ---------------------------------------------------------C$$code$$__rt_stkovf |76     |__rt_stkovf_split_*        ---------------------------------------------------------C$$code$$__jmp       |100    |longjmp, setjmp            ---------------------------------------------------------C$$code$$__divide    |256    |__rt_sdiv, __rt_udiv,                           |       |__rt_udiv10,               ---------------------------------------------------------All Areas            |736    |__rt_sdiv10, __rt_divtest  ---------------------------------------------------------</PRE><P>If floating point support is definitely not required, then the EnsureNoFPSupport variable can be set to {TRUE}, and some extra space will be saved.  After making any modifications to <B>rtstand.s</B>, the size of the various areas can be found by using the command:<P><CODE><PRE>decaof -b rtstand.o</CODE></PRE>From the above table it is clear that for many applications the standalone runtime library will be roughly 0.5Kb.<P><H2>Related topics</H2><UL><LI><A HREF="./3acba.html#XREF36909">Register usage under the ARM procedure call standard</A>;<LI><A HREF="./3acbc.html#XREF35534">In-Line SWIs</A>.</UL>