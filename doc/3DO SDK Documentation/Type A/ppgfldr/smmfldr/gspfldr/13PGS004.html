<A NAME="XREF28249"><H1>ReturnPreviousControlPad</A></H1><A NAME="XREF21163"></A>Returns the state of the control pad as it is remembered.<P><H3>Synopsis</H3><CODE>int32 ReturnPreviousControlPad (int32 whichPad)</CODE><P><H3>Description</H3>Returns the state of the specified control pad as it is remembered from the last time <CODE>DoControlPad()</CODE> was called and a new state for the control pad existed. <P><H3>Arguments</H3><DL><DT>whichPad<DD>Index of the control pad to query. </DL><H3>Return Value</H3>Returns 0 if successful or a negative error code if an error occurs. <P><H3>Caveats</H3>This function is neither multi-thread or multi-task capable or safe. <P>Because of system restrictions on item ownership and using items, <CODE></CODE>you should call this function from the task or thread which called <CODE>InitControlPad()</CODE>. <P><CODE>InitControlPad()</CODE> and <CODE>InitEventUtility()</CODE> create message ports and message items which only the task which has created them can use. Hence, <CODE>DoControlPad()</CODE> can only be called by that same task. If other tasks or threads attempt this errors result because those tasks or threads do not own the appropriate message ports and messages.<P>To make this function multi-thread capable, you would need to spawn a thread that communicates directly with the event broker, and with all the other tasks that will consume event information. <P><H3>Associated Files</H3>controlpad.c, controlpad.h<P><H3>Location</H3>examples/Exampleslib <P><H3>See Also</H3><A HREF="./13PGS002.html#XREF22018"><CODE>InitControlPad</A>, <A HREF="./13PGS003.html#XREF23856">KillControlPad</A></CODE><P>