<TITLE>Using the Locale Structure</TITLE><H1>Using the Locale Structure</H1><HR>The main use of the International folio is to obtain the target language and country codes. The folio also provides tools to format dates, numbers, and currency for the target language and country. This section describes how to use these tools.<P><H2>Determining the Current Language and Country</H2>The<CODE> intlOpenLocale()</CODE> call determines the current user settings for language or country:<P><DL><DD><CODE>Item intlOpenLocale(const TagArg *tags)</CODE><BR></DL>This call accepts one argument, <CODE>tags</CODE>, a pointer to a tag argument list. This pointer is currently unused and should be set to NULL. <CODE>intlOpenLocale()</CODE> returns an <CODE>Item</CODE>.<P>The application should then use the following call to obtain the Locale structure for the <CODE>Item</CODE>:<P><DL><DD><CODE>Locale *intlLookupLocale(Item locItem)</CODE><BR></DL>This call accepts one argument, <CODE>locItem</CODE>, an Item as returned from <CODE>intlOpenLocale()</CODE>. The language code in the <CODE>Locale</CODE> structure can then determine which set of messages and artwork to use.<P>For example, if the language code were "de," the application would use a directory containing the German message text and artwork ("de" being the code for Deutsch). The application has a directory containing message text and artwork for each language code it uses.<P><B>Note: </B>An application must supply any text or artwork it displays. The application must supply text strings or artwork for each language it supports.<P>When an application finishes using an Item, use the following call to terminate its use of it:<P><DL><DD><CODE>Err intlCloseLocale(Item locItem)</CODE><BR></DL><CODE>intlCloseLocale()</CODE> l accepts one argument, <CODE>locItem</CODE>, the item to be closed. It returns zero if the call was successful, otherwise, an error code is returned.<P><H2>Working With International Character Strings</H2><H3>Comparing Character Strings</H3>Applications use the <CODE>intlCompareStrings()</CODE> function to compare strings and sort text to be displayed. Each language sorts text in different ways. <CODE>intlCompareStrings()</CODE> adapts its behavior to the current language. By using this function, your title sorts text in the appropriate manner for the target culture:<P><DL><DD><CODE>int32 intlCompareStrings(Item locItem, const unichar *string1, const char *string2)</CODE><BR></DL>This call accepts three arguments: <CODE>locItem</CODE> is a Locale Item obtained from <CODE>intlOpenLocale()</CODE>, <CODE>string1</CODE> is a pointer to the first string to compare, and <CODE>string2</CODE> is a pointer to the second string to compare.<P>The comparison is performed according to the collation rules of <CODE>locItem</CODE>. <CODE>intlCompareStrings()</CODE> is similar to the standard C <CODE>strcmp()</CODE> function, except that it handles sorting variations of different languages.<P><CODE>IntlCompareStrings()</CODE> returns -1 if <CODE>string1</CODE> is less than <CODE>string2</CODE>; 0 if <CODE>string1</CODE> is equal to <CODE>string2</CODE>; and 1 if <CODE>string1</CODE> is greater than <CODE>string2</CODE>. <CODE>INTL_ERR_BADITEM</CODE> is returned if <CODE>locItem</CODE> was not a valid Item.<P><H3>Changing Letters In Character Strings</H3><CODE>intlConvertString()</CODE> strips diacritical marks and changes the letter case of words or characters. This function handles the language differences in rules for case conversion. It is similar to the standard C <CODE>toupper()</CODE> and <CODE>tolower()</CODE> functions.<P><DL><DD><CODE>int32 intlConvertString(Item locItem, const unichar *string, unichar *result, uint32 resultSize, uint32 flags);</CODE><BR></DL>The call accepts five arguments: <CODE>locItem</CODE> is an Item returned from <CODE>intlOpenLocale(),</CODE> <CODE>string</CODE> is the string to be changed, <CODE>result</CODE> is where the result of the conversion is placed, <CODE>resultSize</CODE> is the number of bytes available in <CODE>result</CODE>, and <CODE>flags</CODE> indicates the conversion to be performed. The string copied to result is guaranteed to be NULL-terminated.<P>If successful, <CODE>intlConvertString()</CODE> returns a positive number indicating the number of characters in <CODE>result</CODE>. Otherwise, it returns an error code.<P><H3>Changing Character Sets</H3><CODE>intlTransliterateString()</CODE> converts a string from one character set to another character set. <P>The International folio always generates UniCode strings. For example, <CODE>intlFormatNumber()</CODE> generates a UniCode string holding the formatted number. The 3DO Portfolio currently supplies simple text output routines in Lib3DO which only accept ASCII text. To display the formatted number, an application must convert the UniCode string generated by the International folio to ASCII and call the text output routines.<P><CODE>intlTransliterateString()</CODE> can be used to convert data files generated in ASCII to UniCode or to convert the output of the International folio into ASCII for use by other tools.<P><CODE>intlTranliterateString()</CODE> is called as follows:<P><DL><DD><CODE>int32 intlTransliterateString(const void *string, CharacterSets stringSet, void *result, CharacterSets resultSet, uint32 resultSize, uint8 unknownFiller);</CODE><BR></DL>The call accepts six arguments: <CODE>string</CODE> is the string to convert, <CODE>stringSet</CODE> is the character set of the string to convert, <CODE>result</CODE> is where to put the converted string, <CODE>resultSet</CODE> is the character set to use for the resulting string, <CODE>resultSize</CODE> is the number of bytes available in <CODE>result</CODE>, and <CODE>unknownFiller</CODE> is used as filler for characters that cannot be converted.<P>If successful, <CODE>intlTransliterateString()</CODE> returns a positive number indicating the number of characters in <CODE>result</CODE>. Otherwise, it returns an error code.<P><H3>Providing C Functionality</H3><CODE>intlGetCharAttrs()</CODE> provides functionality similar to the standard C functions <CODE>isupper()</CODE>, <CODE>islower()</CODE>, etc. It is called as follows:<P><DL><DD><CODE>uint32 intlGetCharAttrs(Item locItem, unichar character);</CODE><BR></DL>The call accepts two arguments: <CODE>locItem</CODE>, an <CODE>Item</CODE> as returned by <CODE>intlOpenLocale()</CODE>; and <CODE>character</CODE>, the character for which attributes should be returned.<P>If successful, <CODE>intlGetCharAttrs()</CODE> returns a bit mask which indicates the attributes of the character. <CODE>INTL_ERR_BADITEM</CODE> is returned if <CODE>locItem</CODE> is not a valid <CODE>Item</CODE>.<P><H2>Formatting Numbers or Currency</H2>Numbers are represented in different ways in different countries, so a title should use the following call to format a number to be displayed in the correct manner:<P><DL><DD><CODE>int32 intlFormatNumber(Item locItem, const NumericSpec *spec, uint32 whole, uint32 frac, bool negative, bool doFrac, unichar *result, uint32 resultSize);</CODE><BR></DL>The call accepts seven arguments: <CODE>locItem</CODE> is an Item returned from <CODE>intlOpenLocale()</CODE>, <CODE>spec</CODE> is the format specification for the number (usually taken from the <CODE>Locale</CODE> structure), <CODE>whole</CODE> is the whole component of the number, <CODE>frac</CODE> is the decimal component of the number expressed in billionths (to the right of the decimal mark), <CODE>negative</CODE> is a Boolean that indicates whether the number is negative, <CODE>doFrac</CODE> is a flag indicating which portions of the number should be formatted (if TRUE, the entire number with a decimal mark is output, if FALSE, only the whole part of the number is output), <CODE>result</CODE> is where the formatted number is put, and <CODE>resultSize</CODE> is the number of bytes in <CODE>result</CODE>.<P>The number is formatted according to the rules specified in <CODE>locItem</CODE> and <CODE>spec</CODE>. The string copied to <CODE>result</CODE> is guaranteed to be NULL-terminated.<P>If successful, <CODE>intlFormatNumber()</CODE> returns a positive number indicating the number of characters in <CODE>result</CODE>. Otherwise, it returns an error code.<P><H2>Formatting Dates</H2>An application should use the following call to format a date to be displayed:<P><DL><DD><CODE>int32 intlFormatDate(Item locItem, DateSpec spec, const GregorianDate *date, unichar *result, uint32 resultSize);</CODE><BR></DL>The call accepts five arguments: <CODE>locItem</CODE> is an Item as returned from <CODE>intlOpenLocale()</CODE>, <CODE>spec</CODE> is the format specification for the date (usually taken from the <CODE>Locale</CODE> structure), <CODE>date</CODE> is the date to format, <CODE>result</CODE> is where to put the formatted date, and <CODE>resultSize</CODE> is the number of bytes in <CODE>result</CODE>. The date is formatted according to the rules of <CODE>locItem</CODE> and <CODE>spec</CODE> arguments. The string copied into <CODE>result</CODE> is guaranteed to be NULL-terminated.<P>If successful, <CODE>intlFormatDate()</CODE> returns a positive number indicating the number of characters in result. Otherwise, an error code is returned.<P><A NAME="XREF23143"></A>