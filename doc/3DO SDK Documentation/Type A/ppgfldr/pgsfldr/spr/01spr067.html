<TITLE>FreeMemToMemLists</TITLE><A NAME="XREF28914"><H1>FreeMemToMemLists </A></H1><A NAME="XREF28708"></A>Returns memory to the free pool.<P><H3>Synopsis</H3><CODE>void FreeMemToMemLists( List *l, void *p, int32 size )</CODE><P><H3>Description</H3>The procedure returns a block of memory that was allocated with <CODE>AllocMemFromMemLists()</CODE> to the specified free memory pool (a list of memory lists). <P><B>Note: </B> Unless you are trying to move memory from one memory pool to another, you should always free memory to the same pool that you obtained it from. <P><H3>Arguments</H3><DL><DT>l<DD>A pointer to the memory pool (a list of memory lists) to which to return the memory block. </DL><DL><DT>p<DD>A pointer to the memory to free. This value may be NULL, in which case this function just returns. </DL><DL><DT>size<DD>Number of bytes to free. This must be the same size that was passed to AllocMemFromMemLists() to allocate the block. See <A HREF="#XREF31542">FreeMem</A> for additional information.</DL><H3>Implementation</H3>Folio call implemented in kernel folio V20. <P><H3>Associated Files</H3><DL><DT>mem.h<DD>ANSI C Prototype </DL><DL><DT>clib.lib<DD>ARM Link Library </DL><H3>Notes</H3>You can enable memory debugging in your application by compiling your entire project with the MEMDEBUG value defined on the compiler's command-line. Refer to the <CODE>CreateMemDebug()</CODE> function for more details. <P><H3>See Also</H3><CODE><A HREF="./01spr004.html#XREF40501"><CODE>AllocMem</A>(), <A HREF="./01spr007.html#XREF42660">AllocMemFromMemLists</A>(), <A HREF="./01spr064.html#XREF31542">FreeMem</A>() </CODE><P></CODE><H1><LINK NAME="XREF28914"></LINK></H1><HR>